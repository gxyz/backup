author: me
title: Elixir学习之数据类型和操作符
date: 2016-12-11 21:52:22
tags: 
    - Elixir
---


Elixir中的数量类型很丰富，与一般的编程语言还有一些不同


## 值类型

首先是值类型，主要包括数字，原子，区间和正则表达式。

#### 整数

整数字面量可以是十进制(1234)，十六进制(0xcafe)，八进制(0o765)和二进制(0b1010)；十进制数可以包含下划线来增加可读性。

大小没有限制

eg:

```
10 100 13242  # 十进制
0b1010101     # 二进制
0o567         # 八进制
0xfff         # 十六进制
```

#### 浮点数

使用含小数点的十进制数表示。

> 注意: 小数点前后都必须有数字, 并且结尾的指数是可选的。

浮点数符合IEEE754标准的双精度表示，拥有16位数字的精度并且指数最多可达10^308

```
3.1415926
1.89e-5
```

#### 原子

原子是常量，用于表示某些东西的名字。它以冒号(:)开头，其后跟随一个原子单词或者Elixir运算符

原子单词由字母，数字，下划线和符号"@"构成，以感叹号或者问号结尾。如果不符合前面的标准，就需要加""将原子名括起来

```
:is_binary?

:"he/dew"
```

原子的名字就是它的值, 是独一无二的，用处用来与其他类型一起，作为标识之用


#### 区间

```
start..end
```

start和end可以是任意类型。但是如果想遍历区间中的值，它的两端必须是整数。


#### 正则表达式

Elixir支持正则表达式字面量，写作`~r{regexp}`或者 `~r{regexp}opts`,除了语法不太相同以外跟其他语言的正则表示式的使用是一样的

> regexp -- 正则表达式
> opts是一个或多个单字符选项，他们会改变字面量匹配的行为

opts可以是:

- f  强制模式从多行文本的第一行开始匹配
- g  支持命名分组
- i  忽略大小写
- m  如果目标字符串是多行文本,^和$分别匹配行首和行尾，\A和\z匹配整个字符串的开头和结尾
- r  通常*和+是最大匹配模式，就匹配的越多越好(贪婪模式)，r是非贪婪模式
- s  允许 点"." 来匹配任意换行符 
- u  开启unicode匹配，类型与\p
- x  开启扩展模式－－－忽略空格和注释

这里的`{` 和`}`不是一定的，可以使用`~r/ ../`等等任意非字母和数字的字符都可以，不过花括号比较好用
 
## 系统类型(后面学习到多进程的时候在详细写)

#### PID和端口

PID是本地或者远程进程的引用，而端口是读/写资源（通常是对应用程序外部）的引用

当前进程的PID值可以通过self获得，当一个新的进程被创建时会得到一个新的PID

#### 引用

make_ref函数可以用于创建全局唯一的引用；任何其他的引用都不会与之相等。

## 集合类型

Elixir的集合类型可以包含任意类型的值（包括其他集合)

#### 元组

表示一组有序元素的集合

元组写在一组花括号中,如下，可以包含不同类型

```
{1, 2}   {:ok, 42, "dew"}  
```

通常元组由两到四个元素组成

> 可以用于模式匹配
> 通常函数在不出错的情况下会返回一个元组，它的第一个元素为一个原子 :ok

#### 列表

Elixir中的列表(与数组不同，Elixir的元组更像是其他语言中的数组)是一个链式数据结构（链表）。列表要么为空，要么分为首部和剩下的部分。首部是一个值，剩下的部分还是一个列表

在列表的前面插入数据通常会更快，所有经常使用下面
```
[4 | [1,2,3]] = [4, 1, 2, 3]
```

列表的一些操作

```
[1,3] ++ [2,4]  = [1,3,2,4]  # 连接
[1,2,3,4] -- [1,3] = [2,4]    # 差集
1 in [1,2,3,4]  = true       # 属于
```

#### 关键字列表

我们经常需要一组键值对，Elixir提供了一个简写方式

```
[name: "gdb", city: "xi'an", likes: "programming"]
```

Elixir会将其转换为一个由双值元组组成的列表:

```
[{:name, "gdb"}, {:city, "xi'an"}, {:likes, "programming"}]
```

#### 散列表

散列表是一个键值对的集合

```
%{key => value, key => value}

%{"name" => "gdb", "age" => 10}
```

如果键是原子类型，也可以使用类似上面的简写方法:
```
%{name: "gdb", age: 10}

等同于

%{:name => "gdb", :age => 10}
```

访问散列表，可以通过键来获取值，可以使用[key] 的语法来获取值，如果键是原子，还可以使用点"."语法访问,使用点语法时如果没有对应的键,就keyError

#### 二进制型

二进制型被放置在<< 和 >>之间

此基本表示法将连续的整数逐个转换为字节:

```
> bin = <<1,2>>
<<1,2>>
> byte_size bin
2
```

还可以通过修饰符控制类型和每个字段的大小(位)。

```
<< 3 :: size(2), 5 :: size(4), 1 :: size(2) >>
```

#### 真值

Elixir有三个值与布尔计算相关: true, false, nil。nil在布尔环境中被当做false.

这三个值，其实都是原子， true 和 :true是等价的。

除了 false和nil之外都是真值

## 运算符

**比较运算符**

```
===  严格相等 1 === 1.0 false
!==  严格不相等 
==   值相等 1 == 1.0  true
!=   值不等
>
>=
<
<=
```

Elixir中不同类型值的大小关系:

```
number < atom < reference < function < port < pid < tulpe < map < list < binary
```

**布尔运算符**


```
or and  not    
```

优先计算第一个参数的真值，短路运算； 主要这些运算符的左边必须是false 和true

```
iex> true and 1
1
iex> false and 1
false
iex> true or 1
true
iex> not true
false

iex> 1 and true
** (ArgumentError) argument error: 1
iex> 1 or false
** (ArgumentError) argument error: 1
iex> not 1
** (ArgumentError) argument error: 1
```

注意:

1. 对于and 操作符，只要左边是true, 结果就一定等于右边； 只要左边是false,结果就一定是false
2. 对于false 操作符，只要左边是true, 结果就一定是true； 只要左边是false,结果就一定等于右边
3. 只要左边不是true或者false, 就会抛出`** (ArgumentError) argument error`的错误


**松弛布尔运算符**

这些运算符接受任意类型的值。除false和nil以外都是真值

```
||
&&
!
```

**算数运算符**

```
+ - * / div rem
```

要主要的是这里的除法的结果永远是浮点数，要想进行整数除法使用div, 还有rem是用来求余数的

```
iex> 4 / 2
2.0

iex> 4 / 3
1.3333333333333333

iex> 4 div 2
2

iex> 4 div 3
1

iex> 4 rem 2
0

iex> 4 rem 3
1 
```

**连接运算符**

<>  连接讲个二进制类型
++   连接两个列表
-- 返回list1中包含但list2中不包含的元素
in  属于操作符

```
iex> <<1,2,3>>  <> <<4,5,6>>
<<1, 2, 3, 4, 5, 6>>

iex> [1,3,4] ++ [4,5,6]
[1, 3, 4, 4, 5, 6]

iex> [2, 3, 4] -- [1, 2, 3]
[4]

iex> 1 in [1, 2, 3]
true
```
